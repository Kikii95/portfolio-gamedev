---
title: "Multithreaded Game"
description: "Jeu optimisé avec multithreading C++ pour gameplay fluide et traitement parallèle"
date: "2025-09-15"
category: "école"
tags: ["C++", "Threading", "CMake", "SFML", "Performance"]
featured: false
status: "archive"
gallery: []
---

# Multithreaded Game

Jeu démontrant les techniques avancées de multithreading C++ pour un gameplay fluide.

## Contexte

Projet école GTech3, 2 mois. Équipe de 4, rôle : développeur systèmes core.

Focus sur le traitement parallèle et la synchronisation de threads pour des systèmes de jeu temps réel.

## Cahier des Charges

Consignes école :
- Paralléliser au moins 2 systèmes de jeu
- Gestion de ressources thread-safe
- Frame time stable < 16ms (60 FPS)
- C++17/20 avec std::thread, pas de race conditions

## Stack

- C++17/20
- CMake
- SFML (graphismes)
- std::thread, mutex, condition variables

## Notre Implémentation

Au-delà des 2 systèmes demandés, nous avons implémenté une architecture complète :

- **4 threads dédiés** : Main (game loop + input), Render, Physics, Audio — vs 2 demandés
- **Job system custom** : parallélisme scalable avec work stealing, pas juste des threads fixes
- **Structures lock-free** : queues SPSC/MPSC pour minimiser les contentions
- **Profiler intégré** : visualisation des frame times par système, identification des bottlenecks

## Points Techniques

Architecture multi-thread avec threads dédiés :
- Main : coordination game loop + input
- Render : soumission graphique
- Physics : collision et simulation
- Audio : traitement son

Synchronisation via mutex locks, opérations atomiques et condition variables pour éviter les race conditions tout en maintenant la performance.

## Liens

Code disponible sur demande.
